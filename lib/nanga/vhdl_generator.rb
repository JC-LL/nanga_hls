module Nanga

  class VHDLGenerator <  CompilerPass

    def run ast
      ast.accept(self)
    end

    def visitDef func,args=nil
      puts " |--[+] generating code for function '#{func.name.str}'"
      generate_pkg(func)
      generate_controler(func)
      generate_datapath(func)
    end

    def ieee_header
      code=Code.new
      code << "--generated by NangaHLS"
      code << "library ieee;"
      code << "use ieee.std_logic_1164.all;"
      code << "use ieee.numeric_std.all;"
      code.newline
      code
    end

    def generate_pkg func
      puts "     |--[+] package"
      controler=func.controler
      # first, establish the list of muxes and their possible controls
      mux_values={}
      controler.states.each do |state|
        state.controls.each do |control|
          mux_values[control.mux.id]||=[]
          mux_values[control.mux.id] << control.value
        end
      end
      max_mux_values={}
      mux_values.each do |mux_id,values|
        max_mux_values[mux_id]=values.max
      end
      code=Code.new
      code << ieee_header
      code << "package #{func.name.str}_pkg is"
      code.indent=2
      code.newline
      state_names=controler.states.map{|state| "S#{state.id}"}
      code << "type state_t is (#{state_names.join(',')});"
      code.newline
      code << "type controls_t is record"
      code.indent=4
      max_mux_values.keys.sort.each do |mux_id|
        code << "mux_#{mux_id} : integer range 0 to #{max_mux_values[mux_id]};"
      end
      code.indent=2
      code << "end record;"
      code.newline
      code << "type microprogram_type is array(state_t) of controls_t;"
      code.newline
      code << "constant MICROPROGRAM : microprogram_type := ("
      code.indent=4
      # default to 0,0...,0 :
      cmds_default={}
      max_mux_values.keys.sort.each do |mux_id|
        cmds_default[mux_id]=0
      end
      controler.states.each do |state|
        cmds=cmds_default.clone
        state.controls.each do |control|
          cmds[control.mux.id]=control.value
        end
        assoc=cmds.values
        code << "S#{state.id} => (#{assoc.join(',')}),"
      end

      code.indent=2
      code << ");"
      code.newline
      code.indent=0
      code << "end package;"
      filename="#{func.name.str}_pkg.vhd"
      puts code.finalize
      code.save_as filename
    end

    def generate_controler(func)
      puts "     |--[+] controler entity/arch"
      controler=func.controler
      entity_name="#{controler.name}"
      code=Code.new
      code << ieee_header
      code.newline
      code << "library #{func.name.str}_lib;"
      code << "use #{func.name.str}_lib.#{func.name.str}_pkg.all;"
      code.newline
      code << "entity #{entity_name} is"
      code.indent=2
      code << "port("
      code.indent=4
      code << "reset_n  : in  std_logic;"
      code << "clk      : in  std_logic;"
      code << "go       : in  std_logic;"
      code << "done     : out std_logic;"
      code << "controls : out controls_t"
      code.indent=2
      code << ");"
      code.indent=0
      code << "end entity;"
      code.newline
      code << "architecture rtl of #{entity_name} is"
      code.indent=2

      code << "signal state_r,state_c : state_t;"
      code.indent=0
      code << "begin"
      code.indent=2
      code.newline
      code << "tick_p : process(reset_n,clk)"
      code << "begin"
      code.indent=4
      code << "if reset_n='0' then"
      code.indent=6
      code << "state_r <= S0;"
      code.indent=4
      code << "elsif rising_edge(clk) then"
      code.indent=6
      code << "state_r <= state_c;"
      code.indent=4
      code << "end if;"
      code.indent=2
      code << "end process;"
      code.newline
      code << "next_state_p : process(go,state_r)"
      code << "begin"
      code.indent=4
      code << "done <= '0';"
      code << "case state_r is"
      code << "when S0 =>"
      code.indent=6
      code << "if go='1' then"
      code.indent=8
      code << "state_c <= S1;"
      code.indent=6
      code << "end if;"
      code.indent=4
      # controler.states[1..-2].each do |state|
      #   code << "when S#{state.id} =>"
      #   code.indent=6
      #   code << "state_c <= S#{state.id+1};"
      #   code.indent=4
      # end
      # last state
      last_state=controler.states.last
      code << "when S#{last_state.id} =>"
      code.indent=6
      code << "state_c <= S0;"
      code << "done <= '1';"
      code.indent=4
      code << "when others =>"
      code.indent=6
      code << "state_c <= state_t'succ(state_r);"
      code.indent=4
      code << "end case;"
      code.indent=2
      code << "end process;"
      code.newline
      code << "controls <= MICROPROGRAM(state_r);"

      code.indent=0
      code << "end rtl;"
      puts code.finalize
      filename="#{controler.name}.vhd"
      code.save_as(filename)
    end

    def generate_datapath(func)
      puts " |--[+] generate datapath"
      datapath=func.datapath
      code=Code.new
      filename="#{datapath.name}.vhd"
      code.save_as(filename)
    end
  end
end
