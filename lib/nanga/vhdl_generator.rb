module Nanga

  NANGA_TO_VHDL_OPERATORS={
    add: "+",
    sub: "-",
    mul: "*",
    div: "/",
    and: "and",
    or:  "or",
  }

  class VHDLGenerator <  CompilerPass
    attr_accessor :type
    def run ast
      ast.accept(self)
    end

    def visitDef func,args=nil
      puts " |--[+] processing '#{func.name.str}'"
      generate_pkg(func)
      generate_controler(func)
      generate_datapath(func)
      generate_fsmd(func)
    end

    def nanga_header
      code=Code.new
      code << "-- ---------------------------------------------------"
      code << "-- Generated by NangaHLS "
      code << "-- (c) Jean-Christophe Le Lann - ENSTA Bretagne"
      code << "-- ---------------------------------------------------"
      code
    end

    def ieee_header
      code=Code.new
      code << "library ieee;"
      code << "use ieee.std_logic_1164.all;"
      code << "use ieee.numeric_std.all;"
      code.newline
      code
    end

    def generate_pkg func
      puts "     |--[+] package..... #{func.name.str}_pkg.vhd"
      controler=func.controler
      # first, establish the list of muxes and their possible controls
      mux_values={}
      controler.states.each do |state|
        state.controls.each do |control|
          mux_values[control.mux.id]||=[]
          mux_values[control.mux.id] << control.value
        end
      end
      max_mux_values={}
      mux_values.each do |mux_id,values|
        max_mux_values[mux_id]=values.max
      end
      code=Code.new
      code << nanga_header
      code << ieee_header
      code << "package #{func.name.str}_pkg is"
      code.indent=2
      code.newline
      state_names=controler.states.map{|state| "S#{state.id}"}
      code << "type state_t is (#{state_names.join(',')});"
      code.newline
      code << "type controls_t is record"
      code.indent=4
      max_mux_values.keys.sort.each do |mux_id|
        code << "mux_#{mux_id} : integer range 0 to #{max_mux_values[mux_id]};"
      end
      code.indent=2
      code << "end record;"
      code.newline
      code << "type microprogram_type is array(state_t) of controls_t;"
      code.newline
      code << "constant MICROPROGRAM : microprogram_type := ("
      code.indent=4
      # default to 0,0...,0 :
      cmds_default={}
      max_mux_values.keys.sort.each do |mux_id|
        cmds_default[mux_id]=0
      end
      controler.states.each do |state|
        cmds=cmds_default.clone
        state.controls.each do |control|
          cmds[control.mux.id]=control.value
        end
        assoc=cmds.values
        code << "S#{state.id} => (#{assoc.join(',')}),"
      end

      code.indent=2
      code << ");"
      code.newline
      code.indent=0
      code << "end package;"
      filename="#{func.name.str}_pkg.vhd"
      code.save_as filename
    end

    def generate_controler(func)
      puts "     |--[+] controler... #{func.name.str}_controler.vhd"
      entity_name=func.name.str+"_controler"
      controler=func.controler
      code=Code.new
      code << nanga_header
      code << ieee_header
      code << "library #{func.name.str}_lib;"
      code << "use #{func.name.str}_lib.#{func.name.str}_pkg.all;"
      code.newline
      code << "entity #{entity_name} is"
      code.indent=2
      code << "port("
      code.indent=4
      code << "reset_n  : in  std_logic;"
      code << "clk      : in  std_logic;"
      code << "go       : in  std_logic;"
      code << "done     : out std_logic;"
      code << "controls : out controls_t"
      code.indent=2
      code << ");"
      code.indent=0
      code << "end entity;"
      code.newline
      code << "architecture rtl of #{entity_name} is"
      code.indent=2

      code << "signal state_r,state_c : state_t;"
      code.indent=0
      code << "begin"
      code.indent=2
      code.newline
      code << "tick_p : process(reset_n,clk)"
      code << "begin"
      code.indent=4
      code << "if reset_n='0' then"
      code.indent=6
      code << "state_r <= S0;"
      code.indent=4
      code << "elsif rising_edge(clk) then"
      code.indent=6
      code << "state_r <= state_c;"
      code.indent=4
      code << "end if;"
      code.indent=2
      code << "end process;"
      code.newline
      code << "next_state_p : process(go,state_r)"
      code << "begin"
      code.indent=4
      code << "done <= '0';"
      code << "case state_r is"
      code << "when S0 =>"
      code.indent=6
      code << "if go='1' then"
      code.indent=8
      code << "state_c <= S1;"
      code.indent=6
      code << "end if;"
      code.indent=4
      # controler.states[1..-2].each do |state|
      #   code << "when S#{state.id} =>"
      #   code.indent=6
      #   code << "state_c <= S#{state.id+1};"
      #   code.indent=4
      # end
      # last state
      last_state=controler.states.last
      code << "when S#{last_state.id} =>"
      code.indent=6
      code << "state_c <= S0;"
      code << "done <= '1';"
      code.indent=4
      code << "when others =>"
      code.indent=6
      code << "state_c <= state_t'succ(state_r);"
      code.indent=4
      code << "end case;"
      code.indent=2
      code << "end process;"
      code.newline
      code << "controls <= MICROPROGRAM(state_r);"

      code.indent=0
      code << "end rtl;"
      filename="#{entity_name}.vhd"
      code.save_as(filename)
    end

    def generate_datapath(func)
      puts "     |--[+] datapath.... #{func.name.str}_datapath.vhd"
      @type="signed(#{func.dim-1} downto 0)"
      datapath=func.datapath
      consts =datapath.nodes.select{|e| e.is_a?(RTL::Const)}
      inputs =datapath.nodes.select{|e| e.is_a?(RTL::Input)}
      outputs=datapath.nodes.select{|e| e.is_a?(RTL::Output)}
      regs   =datapath.nodes.select{|e| e.is_a?(RTL::Reg)}
      fus    =datapath.nodes.select{|e| e.is_a?(RTL::FunctionalUnit)}
      # build a hash of components input ports to incoming Edge
      drivers={}
      datapath.edges.each do |edge|
        drivers[edge.sink]=edge.var
      end
      #
      name=func.name.str
      datapath_name="#{name}_datapath"
      code=Code.new
      code << nanga_header
      code << ieee_header
      code << "library #{func.name.str}_lib;"
      code << "use #{name}_lib.#{name}_pkg.all;"
      code.newline
      code << "entity #{datapath_name} is"
      code.indent=2
      code << "port("
      code.indent=4
      code << "reset_n  : in  std_logic;"
      code << "clk      : in  std_logic;"
      code << "controls : in  controls_t;"
      inputs.each do |input|
        code << "#{input.name} : in  #{type};"
      end
      outputs.each do |output|
        code << "func_return : out #{type};"
      end
      code.indent=2
      code << ");"
      code.indent=0
      code << "end entity;"
      code.newline
      code << "architecture rtl of #{datapath_name} is"
      code.indent=2
      code << "-- declare constants (#{consts.size})"
      consts.sort_by{|const| const.name}.each do |const|
        code << "constant #{const.name.downcase} : #{type} := to_signed(#{const.val.str},#{func.dim});"
      end
      code << "-- declare registers"
      regs.sort_by{|reg| reg.name}.each do |reg|
        code << "signal #{reg.name} : #{type};"
      end
      code << "-- declare functional units signals"
      fus.sort_by{|fu| fu.name}.each do |fu|
        code << "signal #{fu.name}       : #{type};"
        code << "signal #{fu.name}_left  : #{type};"
        code << "signal #{fu.name}_right : #{type};"
      end

      code.indent=0
      code << "begin"
      code.indent=2
      code << "-- ==== registers ===="
      regs.sort_by{|reg| reg.name}.each do |reg|
        mux=reg.mux
        code << "#{reg.name}_p : process(reset_n,clk)"
        code << "begin"
        code.indent=4
        code << "if reset_n='0' then"
        code.indent=6
        code << "#{reg.name} <= to_signed(0,#{func.dim});"
        code.indent=4
        code << "elsif rising_edge(clk) then"
        code.indent=6
        code << "case controls.mux_#{mux.id} is"
        mux.inputs.each_with_index do |mux_input,idx|
          if idx > 0
            code << "when #{idx} => "
            code.indent=8
            code << "#{reg.name} <= #{drivers[mux_input]};"
            code.indent=6
          end
        end
        code << "when others =>"
        code.indent=8
        code << "null;"
        code.indent=6
        code << "end case;"
        code.indent=4
        code << "end if;"
        code.indent=2
        code << "end process;"
        code.newline
      end

      code << "-- #{"FUNCTIONAL UNITS".center(50,'-')}"

      fus.each do |fu|
        code << "-- #{fu.name.center(50,'.')}"
        # ====== LEFT
        mux=fu.mux[:left]
        if mux.inputs.size > 1
          assign_indent="#{fu.name}_left <=".size
          code << "#{fu.name}_left <= #{drivers[mux.inputs.first]} when controls.mux_#{mux.id}=0 else"
          code.indent=2+assign_indent+1
          mux.inputs[1..-1].each_with_index do |input,idx|
            code << "#{drivers[input]} when controls.mux_#{mux.id}=#{idx} else"
          end
          code << "#{drivers[mux.inputs.last]};"
        else
          code << "#{fu.name}_left <= #{drivers[mux.inputs.first]};"
        end
        code.indent=2
        # ===== RIGHT
        mux=fu.mux[:right]
        assign_indent="#{fu.name}_right <=".size
        if mux.inputs.size > 1
          code << "#{fu.name}_right <= #{drivers[mux.inputs.first]} when controls.mux_#{mux.id}=0 else"
          code.indent=2+assign_indent+1
          mux.inputs[1..-1].each_with_index do |input,idx|
            code << "#{drivers[input]} when controls.mux_#{mux.id}=#{idx} else"
          end
          code << "#{drivers[mux.inputs.last]};"
        else
          code << "#{fu.name}_right <= #{drivers[mux.inputs.first]};"
        end
        code.indent=2
        # ===== operations
        op=NANGA_TO_VHDL_OPERATORS[fu.op]
        code << "#{fu.name} <= resize(#{fu.name}_left #{op} #{fu.name}_right,#{func.dim});"
        code.newline
      end
      code  << "-- connect output"
      outputs.each do |output|
        # mind that output is a RTL Node. We need to find the driver 
        # of its single input *port* : 
        code << "func_return <= #{drivers[output.inputs.first]};"
      end
      code.indent=0
      code << "end rtl;"
      filename="#{datapath_name}.vhd"
      code.save_as(filename)
    end

    def generate_fsmd func
      filename="#{func.name.str}_fsmd.vhd"
      puts "     |--[+] fsmd........ #{filename}"
      datapath_inputs =func.datapath.nodes.select{|e| e.is_a?(RTL::Input)}
      datapath_outputs=func.datapath.nodes.select{|e| e.is_a?(RTL::Output)} #single normaly
      code=Code.new
      code << nanga_header
      code << ieee_header
      code << "library #{func.name.str}_lib;"
      code << "use #{func.name.str}_lib.#{func.name.str}_pkg.all;"
      code.newline
      code << "entity #{func.name.str}_fsmd is"
      code.indent=2
      code << "port("
      code.indent=4
      code << "reset_n : in  std_logic;"
      code << "clk     : in  std_logic;"
      code << "go      : in  std_logic;"
      code << "done    : out std_logic;"
      func.args.each do |arg|
        code << "#{arg.name.str} : in #{type};"
      end
      code << "func_return : out #{type}"
      code.indent=2
      code << ");"
      code.indent=0
      code << "end entity;"
      code.newline
      code << "architecture rtl of #{func.name.str}_fsmd is"
      code.indent=2
      code << "signal controls : controls_t;"
      code.indent=0
      code << "begin"
      code.indent=2
      code.newline
      code << "-- "+"controler instanciation".center(40,'=')
      code << "controler_i: entity #{func.name.str}_lib.#{func.name.str}_controler"
      code << "port map("
      code.indent=4
      code << "reset_n  => reset_n,"
      code << "clk      => clk,"
      code << "go       => go,"
      code << "done     => done,"
      code << "controls => controls,"
      code.indent=2
      code << ");"
      code.newline
      code << "-- "+"datapath  instanciation".center(40,'=')
      code << "datapath_i: entity #{func.name.str}_lib.#{func.name.str}_datapath"
      code << "port map("
      code.indent=4
      code << "reset_n  => reset_n,"
      code << "clk      => clk,"
      code << "controls => controls,"
      func.args.each do |arg|
        code << "#{arg.name.str} => #{arg.name.str},"
      end
      code << "func_return => func_return"
      code.indent=2
      code << ");"
      code.indent=0
      code << "end rtl;"
      code.save_as filename
    end
  end
end
